/**
 * Installation:
 * 1. yarn add -D ts-morph
 * 2. Add this script to your base directory (same as tsconfig.json)
 * 3. Add `codegen` to your `package.json` scripts, ex:
 *    `"codegen": "ts-node codegen.ts",`
 * 4. Run `yard codegen`
 * 5. Use the Cast functions in your `.gen.ts` files to cast to the given interface
 *
 * Want to change something? There are a number of config options under "CONFIG SETTINGS" below.
 */

import fs from 'fs';
import path from 'path';
import {
  InterfaceDeclaration,
  Project,
  PropertySignature,
  SourceFile,
  Type,
  TypeLiteralNode,
  ts,
} from 'ts-morph';

// Simple object containing a bunch of util functions.
const Utils = {
  nullRegex: /\s*\|\s*null\s*|\s*null\s*\|\s*/gi,
  checkTypeNullable: (type: Type<ts.Type>, prop: PropertySignature) =>
    type.isNull() ||
    type.isNullable() ||
    Utils.nullRegex.test(prop.getTypeNodeOrThrow().getText()),

  // Returns the header prefixed to every file that is created by this script
  getGenfileHeader(file: SourceFile) {
    return `// This is an autogenerated file, DO NOT EDIT.
// This file was generated from \`${file.getBaseName()}\` by executing the \`codegen.ts\` file.\n`;
  },
};

// CONFIG SETTINGS

/**
 * The path to the tsconfig.json file for this project. This is used to load the source files while
 * obeying the project's settings.
 */
const TSCONFIG_PATH = path.resolve(__dirname, './tsconfig.json');

/**
 * The extension for generated files. For instance, if the extension is `.gen.ts`, then the
 * generated file for `MyInterface.ts` will be `MyInterface.gen.ts`.
 */
const GEN_FILE_EXT = '.gen.ts';

/**
 * The prefix for all generated functions. For instance, if the prefix is `CastTo`, then the
 * generated function for `ISomeInterface` will be `CastToSomeInterface`.
 */
const FUNC_PREFIX = 'CastTo';

/**
 * If `true`, will try to inline cast functions for interfaces which extend other interfaces.
 * I.e., if `IChild extends IParent`, then the cast function for `IChild` will simply call the
 * cast function for `IParent` instead of checking each property again.
 *
 * If `false`, the cast functions are "inlined" and checks each individual property.
 *
 * Enabling this function can create circular dependencies in your code, depending on your setup.
 * ```
 */
const PREFER_REUSE_CAST_FUNCTIONS = false; // `true` can cause circular dependencies in some projects

/**
 * Must interfaces be prefixed with an `I`?
 *
 * This is primarily useful for having some control over what interfaces are generated. DOM element
 * interfaces, for instance, do _NOT_ have the I-prefix but you often don't want to generate those.
 */
const REQUIRE_I_PREFIX = true;

/**
 * Controls whether or not an interface without any fields/properties can still be casted to, ex:
 * `type IEmpty = { };`
 *
 * `true` will generate all cast functions for all interfaces, even if they have no properties.
 *
 * `false` will skip interfaces with no properties, but as a result the casting function(s) will also
 * not be gnerated.
 */
const OUTPUT_EMPTY_INTERFACES = true;

// Load the source files listed in the tsconfig
const project = new Project();
project.addSourceFilesFromTsConfig(TSCONFIG_PATH);

// Process each file and output the relevant file
project.getSourceFiles().forEach(generateCodegenFile);

console.log('\nüéâ Done generating interface casters! üéâ\n');

function generateCodegenFile(sourceFile: SourceFile) {
  // If this function is called on a previously-generated file, ignore it
  if (sourceFile.getBaseName().endsWith(GEN_FILE_EXT)) {
    return;
  }

  const outputFilePath = path.resolve(
    sourceFile.getDirectoryPath(),
    `./${sourceFile.getBaseNameWithoutExtension()}${GEN_FILE_EXT}`
  );

  // If this file exists already, just straight up remove it.
  // It may be outdated and no longer necessary, so this will prune the file.
  // If it IS needed, then it'll simply be regenerated.
  if (fs.existsSync(outputFilePath)) {
    fs.unlinkSync(outputFilePath);
  }

  const interfaces = sourceFile.getInterfaces().filter(
    (x) =>
      // Ignore non-exported interfaces as they will cause import errors for the generated files
      x.isExported() &&
      // We might only be looking at the `I`-prefixed interfaces
      (REQUIRE_I_PREFIX ? x.getName().charAt(0) === 'I' : true)
  );

  // If there are no interfaces in this file at all, then we don't need to look at it further
  if (interfaces.length == 0) {
    return;
  }
  console.log(sourceFile.getBaseName());

  let imports = new Map<SourceFile, Set<string>>();
  let generatedCode = '';
  let hasOutput = false;

  // for each interface found in this source file...
  interfaces.forEach((int) => {
    const interfaceName = int.getName();

    var compiledPropChecks = processInterface(int, imports);

    if (compiledPropChecks.length === 0) {
      const color = OUTPUT_EMPTY_INTERFACES ? 'üü®' : '‚ùå';
      console.warn(
        `\t${color} No prop checks found for interface "${interfaceName}"`
      );
      if (!OUTPUT_EMPTY_INTERFACES) {
        return;
      }
    }
    hasOutput = true;

    // We may have a type parameter, i.e. this may be a generic function.
    // This snippet will create the necessary `<T, U, ...>` string that's appended to the function
    // as well as the return type.
    let gens = int
      .getTypeParameters()
      .map((v) => v.getName())
      .join(',');
    if (gens) {
      gens = '<' + gens + '>';
    }

    // Since the cast functions accept 'any' as a param, we need to double check the possibility
    // that the input is null/undefined
    compiledPropChecks.unshift('obj !== null && obj !== undefined');

    generatedCode += `
export function ${FUNC_PREFIX}${interfaceName.slice(
      1
    )}${gens}(obj: any): ${interfaceName}${gens} | null {
  return (${compiledPropChecks.join(' && ')}) ? obj : null;
}
`;
  });

  if (!hasOutput) {
    return;
  }

  let importString = '';
  const items = imports.entries();

  let value: [SourceFile, Set<string>];
  while ((value = items.next()?.value)) {
    const [file, members] = value;
    importString += `import type { ${Array.from(members.values()).join(
      ', '
    )} } from '${file.getRelativePathAsModuleSpecifierTo(
      sourceFile.getDirectoryPath()
    )}/${file.getBaseNameWithoutExtension()}';\n`;
  }

  generatedCode =
    Utils.getGenfileHeader(sourceFile) + importString + generatedCode;

  fs.writeFileSync(outputFilePath, generatedCode);
}

function processInterface(
  interfaceDeclaration: InterfaceDeclaration,
  importsRef: Map<SourceFile, Set<string>>,
  isInherited: boolean = false
): string[] {
  const propertiesCheckCode: string[] = [];

  const interfaceName = interfaceDeclaration.getName();
  if (REQUIRE_I_PREFIX && interfaceName.charAt(0) !== 'I') {
    return propertiesCheckCode;
  }

  if (!isInherited) {
    // If this is NOT inherited, then we need to add it to the imports list which is included in
    // the header of the generated file.
    const file = interfaceDeclaration.getSourceFile();
    const list = importsRef.get(file) ?? new Set<string>();
    list.add(interfaceName);
    importsRef.set(file, list);
  }

  // For interfaces with extensions, we will simply confirm that we can cast to the ancestors

  // IF TRYING TO REUSE EXISTING CAST FUNCTIONS...
  if (PREFER_REUSE_CAST_FUNCTIONS) {
    interfaceDeclaration.getBaseDeclarations().forEach((i) => {
      propertiesCheckCode.push(
        `${FUNC_PREFIX}${i.getName()!.slice(1)}(obj) !== null`
      );
    });
  } else {
    interfaceDeclaration.getBaseDeclarations().forEach((i) => {
      if (REQUIRE_I_PREFIX && interfaceName.charAt(0) !== 'I') {
        return propertiesCheckCode;
      }

      if (i.isKind(ts.SyntaxKind.TypeLiteral)) {
        const subProps = processTypeLiteral(<TypeLiteralNode>i);
        propertiesCheckCode.push(...subProps);
      } else {
        const subProps = processInterface(
          <InterfaceDeclaration>i,
          importsRef,
          true
        );
        propertiesCheckCode.push(...subProps);
      }
    });
  }

  // Ensure all methods exist. (Unfortunately we can't check if the return types are compatible!)
  interfaceDeclaration.getMethods().forEach((meth) => {
    const propName = meth.getName();
    propertiesCheckCode.push(`typeof(obj.${propName}) === "function"`);
  });

  // Check the fields for the given interface, confirming the types are correct
  interfaceDeclaration.getProperties().forEach((prop) => {
    const type: Type<ts.Type> = prop.getType();
    if (
      prop.hasQuestionToken() ||
      type.isAny() ||
      type.getTypeArguments().length > 0
    ) {
      return;
    }

    const isNullable = Utils.checkTypeNullable(type, prop);

    const propName = prop.getName();
    if (type.isAnonymous()) {
      // Actually a method but is showing up as a property! Again, can't check the return type.
      propertiesCheckCode.push(`typeof(obj.${propName}) === "function"`);
    } else if (isNullable) {
      propertiesCheckCode.push(
        `(typeof(obj.${propName}) === "${type.getText()}" || obj.${propName} === null)`
      );
    } else if (type.isTypeParameter()) {
      propertiesCheckCode.push(`typeof(obj.${propName}) !== "undefined"`);
    } else {
      propertiesCheckCode.push(
        `typeof(obj.${propName}) === "${(type as Type<ts.Type>).getText()}"`
      );
    }
  });

  if (!isInherited) {
    console.log(`\t‚úÖ ${interfaceName}`);
  }

  return propertiesCheckCode;
}

function processTypeLiteral(interfaceDeclaration: TypeLiteralNode): string[] {
  const propertiesCheckCode: string[] = [];

  // Check the fields for the given interface, confirming the types are correct
  interfaceDeclaration.getProperties().forEach((prop) => {
    const type: Type<ts.Type> = prop.getType();
    if (
      prop.hasQuestionToken() ||
      type.isAny() ||
      type.getTypeArguments().length > 0
    ) {
      return;
    }

    const isNullable = Utils.checkTypeNullable(type, prop);
    const propName = prop.getName();
    if (type.isAnonymous()) {
      // Actually a method but is showing up as a property! Again, can't check the return type.
      propertiesCheckCode.push(`typeof(obj.${propName}) === "function"`);
    } else if (isNullable) {
      propertiesCheckCode.push(
        `(typeof(obj.${propName}) === "${type.getText()}" || obj.${propName} === null)`
      );
    } else if (type.isTypeParameter()) {
      propertiesCheckCode.push(`typeof(obj.${propName}) !== "undefined"`);
    } else {
      propertiesCheckCode.push(
        `typeof(obj.${propName}) === "${(type as Type<ts.Type>).getText()}"`
      );
    }
  });

  return propertiesCheckCode;
}
